https://leetcode.com/problems/binary-tree-level-order-traversal/description/

Description:
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
                      3
                  9       20
                       15     7

The recurssion might lead to stackoverflow at the worst case so queue is better but still.
--------------------------------------------------------------------------------------------------------------------------
Time Complexity: O(n)
Space Complexity: O(n)
Solution:
The first approach is using QUEUE.

I add my values to the queue at each level.
and do q.left and q.right

Code:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    List<List<Integer>> ar=new ArrayList<>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root==null)return ar;
        Queue<TreeNode>q=new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            int size=q.size();
            ArrayList<Integer>arr=new ArrayList<>();
            for(int i=0;i<size;i++){
                TreeNode node=q.poll();
                arr.add(node.val);
                if(node.left!=null)q.add(node.left);
                if(node.right!=null)q.add(node.right);
            }
            ar.add(arr);
        }
        return ar;
    }
}

--------------------------------------------------------------------------------------------------------------------------
RECURSIVE APPROACH:
Time Complexity: O(n)
Space Complexity: O(n)

Input: root = [3,9,20,2,3,15,7]
Step 1: Add 3 (level 0)
[[3]]

Step 2: Add 9 (level 1)
[[3], [9]]

Step 3: Add 2 (level 2)
[[3], [9], [2]]

Step 4: Add 3 (level 2)
[[3], [9], [2, 3]]

Step 5: Add 20 (level 1)
[[3], [9, 20], [2, 3]]

Step 6: Add 15 (level 2)
[[3], [9, 20], [2, 3, 15]]

Step 7: Add 7 (level 2)
[[3], [9, 20], [2, 3, 15, 7]]

Code:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<List<Integer>> ar = new ArrayList<>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null)
            return ar;
        helper(root, 0);
        return ar;
    }

    public void helper(TreeNode node, int level) {
        if (level == ar.size())
            ar.add(new ArrayList<>());

        List<Integer> currentLevel = ar.get(level);
        currentLevel.add(node.val);

        if (node.left != null)
            helper(node.left, level + 1);
        if (node.right != null)
            helper(node.right, level + 1);

    }
}
