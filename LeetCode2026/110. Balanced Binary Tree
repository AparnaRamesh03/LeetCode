https://leetcode.com/problems/balanced-binary-tree/description/


Question:
Example:
[1,2,3,4,5,6,null,8]
return true
Time is O(n)
-------------------------------------------------------------------------------------------------------------------

Solve it like it is a postorder Traversal , the DFS approach.
Here is my approach:

I recurse through each node and check its left and right height.
if difference of height is greater then return false;
else you calculate the height 

Imp: Through this approach you are not recalculating the height but we check the balance immedietly so it is O(n) otherwise O(n2).
-------------------------------------------------------------------------------------------------------------------
Explanation:
                                              1 (h=4)

                                 (h=3) 2               3 (h=2)

                              (h=2) 4    5 (h=1)   6 (h=1)

                            (h=1) 8

8 -> max(0,0)+1 =1
4 -> max(1,0)+1 =2
5 -> max(0,0)+1 =1
2 -> max(2,1)+1 =3
6 -> max(0,0)+1 =1
3 -> max(1,0)+1 =2
1 -> max(3,2)+1 =4

-------------------------------------------------------------------------------------------------------------------

Solution:
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    boolean bal=true;
    public boolean isBalanced(TreeNode root) {
        balance(root);
        return bal;
    }
    public int balance(TreeNode root){
        if(root==null)return 0;
        int left=balance(root.left);
        int right=balance(root.right);
        if(Math.abs(left-right)>1)bal=false;
        return Math.max(left,right)+1;
    }
}



-------------------------------------------------------------------------------------------------------------------
Height O(n2) approach:
boolean isBalanced(TreeNode root) {
    if(root == null) return true;

    int leftHeight = height(root.left);   // separate function
    int rightHeight = height(root.right); // separate function

    if(Math.abs(leftHeight - rightHeight) > 1) return false;

    return isBalanced(root.left) && isBalanced(root.right);
}

int height(TreeNode root) {
    if(root == null) return 0;
    return Math.max(height(root.left), height(root.right)) + 1;
}

-------------------------------------------------------------------------------------------------------------------
Explanation:
                                              1 (h=4)

                                 (h=3) 2               3 (h=2)

                              (h=2) 4    5 (h=1)   6 (h=1)

                            (h=1) 8

1:
left:8->1 4->2 5->1 2->3
right:6->1 3->2
abs(3,2)=1 
isBalance(2) & isBalance(3)

2:
left 8->1 4->2
right 5->1
 like this...
