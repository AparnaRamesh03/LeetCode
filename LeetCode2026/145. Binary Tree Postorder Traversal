https://leetcode.com/problems/binary-tree-postorder-traversal/description/


Question:
Input: root = [1,2,3,4,5,null,8,null,null,6,7,9]

Output: [4,6,7,5,2,9,8,3,1]



            1
         /     \
        2       3
      /   \       \
     4     5       8
          /  \     /
         6    7   9
             

Solution:
--------------------------------------------------------------------------------------------------------------
ITERATIVE:
Two Stack solution is one of the way to solve this.
MainStack -> that takes care of the traversal
PathStack -> that checks if the children are processed.
Rule:
First time you see a node you push the children
Second time you see it (detected by pathstack)->process it(add to result)

Start:
mainStack = [1]
pathStack = []
result = [] 

Peek 1 → first visit      Peek 2 → first visit          Peek 4 → first visit        
pathStack = [1]           pathStack = [1,2]             pathStack = [1,2,4]
mainStack = [1,3,2]       mainStack = [1,3,2,5,4]       mainStack = [1,3,2,5,4]


Peek 4 → second visit     Peek 5 → first visit           Peek 6 → first visit
result = [4]              pathStack = [1,2,5]            pathStack = [1,2,5,6]
mainStack = [1,3,2,5]     mainStack = [1,3,2,5,7,6]      mainStack = [1,3,2,5,7,6]
pathStack = [1,2]


Peek 6 → second visit      Peek 7 → first visit          Peek 7 → second visit
result = [4,6]             pathStack = [1,2,5,7]         result = [4,6,7]
mainStack = [1,3,2,5,7]    mainStack = [1,3,2,5,7]       mainStack = [1,3,2,5]
pathStack = [1,2,5]                                      pathStack = [1,2,5]


Peek 5 → second visit      Peek 2 → second visit         Peek 3 → first visit
result = [4,6,7,5]         result = [4,6,7,5,2]          pathStack = [1,3]
mainStack = [1,3,2]        mainStack = [1,3]             mainStack = [1,3,8]
pathStack = [1,2]          pathStack = [1]


Peek 8 → first visit       Peek 9 → first visit          Peek 9 → second visit
pathStack = [1,3,8]        pathStack = [1,3,8,9]         result = [4,6,7,5,2,9]
mainStack = [1,3,8,9]      mainStack = [1,3,8,9]         mainStack = [1,3,8]
                                                         pathStack = [1,3,8]


Peek 8 → second visit      Peek 3 → second visit          Peek 1 → second visit
result = [4,6,7,5,2,9,8]   result = [4,6,7,5,2,9,8,3]     result = [4,6,7,5,2,9,8,3,1]
mainStack = [1,3]          mainStack = [1]                mainStack = []
pathStack = [1,3]          pathStack = [1]                pathStack = []



✅ Final Output
[4,6,7,5,2,9,8,3,1]


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    ArrayList<Integer>ar=new ArrayList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        if(root==null) return ar;
        
        Stack<TreeNode> mainStack = new Stack<>();
        Stack<TreeNode> pathStack = new Stack<>();
        mainStack.push(root);

        while(!mainStack.isEmpty()){
            root=mainStack.peek();
            if(!pathStack.isEmpty() && pathStack.peek()== root){
                ar.add(root.val);
                pathStack.pop();
                mainStack.pop();
            }else{
                pathStack.push(root);
                if(root.right!=null){
                    mainStack.push(root.right);
                }
                if(root.left!=null){
                    mainStack.push(root.left);
                }
            }
        }
        return ar;
    }
}



--------------------------------------------------------------------------------------------------------------
Recursion:
Postorder is left -> right -> root

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    ArrayList<Integer>ar=new ArrayList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        if(root==null) return ar;
        helper(root);
        return ar;
    }
    public void helper(TreeNode root){
        if(root ==null)return;
        helper(root.left);
        helper(root.right);
        ar.add(root.val);
    }
}



